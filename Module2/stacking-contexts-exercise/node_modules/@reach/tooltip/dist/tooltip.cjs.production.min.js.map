{"version":3,"file":"tooltip.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/tooltip!\n *\n * When the user's mouse or focus rests on an element, a non-interactive popup\n * is displayed near it.\n *\n * Quick definitions:\n *\n * - \"on rest\" or \"rested on\": describes when the element receives mouse hover\n *   after a short delay (and hopefully soon, touch longpress).\n *\n * - \"activation\": describes a mouse click, keyboard enter, or keyboard space.\n *\n * Only one tooltip can be visible at a time, so we use a global state chart to\n * describe the various states and transitions between states that are\n * possible. With all the timeouts involved with tooltips it's important to\n * \"make impossible states impossible\" with a state machine.\n *\n * It's also okay to use these module globals because you don't server render\n * tooltips. None of the state is changed outside of user events.\n *\n * There are a few features that are important to understand.\n *\n * 1. Tooltips don't show up until the user has rested on one, we don't\n *    want tooltips popupping up as you move your mouse around the page.\n *\n * 2. Once any tooltip becomes visible, other tooltips nearby should skip\n *    resting and display immediately.\n *\n * 3. Tooltips stick around for a little bit after blur/mouseleave.\n *\n * TODO: Research longpress tooltips on Android, iOS\n *       - Probably want to position it by default above, since your thumb is\n *         below and would cover it\n *       - I'm thinking after longpress, display the tooltip and cancel any\n *         click events. Then on touchend, so they can read it display the\n *         tooltip for a little while longer in case their hand was\n *         obstructing the tooltip.\n *\n * @see Docs     https://reach.tech/tooltip\n * @see Source   https://github.com/reach/reach-ui/tree/main/packages/tooltip\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.2/#tooltip\n */\n\nimport * as React from \"react\";\nimport { useId } from \"@reach/auto-id\";\nimport {\n  forwardRefWithAs,\n  getOwnerDocument,\n  getDocumentDimensions,\n  makeId,\n  useCheckStyles,\n  useForkedRef,\n  wrapEvent,\n  warning,\n} from \"@reach/utils\";\nimport { Portal } from \"@reach/portal\";\nimport { VisuallyHidden } from \"@reach/visually-hidden\";\nimport { useRect } from \"@reach/rect\";\nimport PropTypes from \"prop-types\";\n\nconst MOUSE_REST_TIMEOUT = 100;\nconst LEAVE_TIMEOUT = 500;\n\n////////////////////////////////////////////////////////////////////////////////\n// States\n\n// Nothing goin' on\nconst IDLE = \"IDLE\";\n\n// We're considering showing the tooltip, but we're gonna wait a sec\nconst FOCUSED = \"FOCUSED\";\n\n// It's on!\nconst VISIBLE = \"VISIBLE\";\n\n// Focus has left, but we want to keep it visible for a sec\nconst LEAVING_VISIBLE = \"LEAVING_VISIBLE\";\n\n// The user clicked the tool, so we want to hide the thing, we can't just use\n// IDLE because we need to ignore mousemove, etc.\nconst DISMISSED = \"DISMISSED\";\n\n////////////////////////////////////////////////////////////////////////////////\n// Events\n\nconst BLUR = \"BLUR\";\nconst FOCUS = \"FOCUS\";\nconst GLOBAL_MOUSE_MOVE = \"GLOBAL_MOUSE_MOVE\";\nconst MOUSE_DOWN = \"MOUSE_DOWN\";\nconst MOUSE_ENTER = \"MOUSE_ENTER\";\nconst MOUSE_LEAVE = \"MOUSE_LEAVE\";\nconst MOUSE_MOVE = \"MOUSE_MOVE\";\nconst REST = \"REST\";\nconst SELECT_WITH_KEYBOARD = \"SELECT_WITH_KEYBOARD\";\nconst TIME_COMPLETE = \"TIME_COMPLETE\";\n\nconst chart: StateChart = {\n  initial: IDLE,\n  states: {\n    [IDLE]: {\n      enter: clearContextId,\n      on: {\n        [MOUSE_ENTER]: FOCUSED,\n        [FOCUS]: VISIBLE,\n      },\n    },\n    [FOCUSED]: {\n      enter: startRestTimer,\n      leave: clearRestTimer,\n      on: {\n        [MOUSE_MOVE]: FOCUSED,\n        [MOUSE_LEAVE]: IDLE,\n        [MOUSE_DOWN]: DISMISSED,\n        [BLUR]: IDLE,\n        [REST]: VISIBLE,\n      },\n    },\n    [VISIBLE]: {\n      on: {\n        [FOCUS]: FOCUSED,\n        [MOUSE_ENTER]: FOCUSED,\n        [MOUSE_LEAVE]: LEAVING_VISIBLE,\n        [BLUR]: LEAVING_VISIBLE,\n        [MOUSE_DOWN]: DISMISSED,\n        [SELECT_WITH_KEYBOARD]: DISMISSED,\n        [GLOBAL_MOUSE_MOVE]: LEAVING_VISIBLE,\n      },\n    },\n    [LEAVING_VISIBLE]: {\n      enter: startLeavingVisibleTimer,\n      leave: () => {\n        clearLeavingVisibleTimer();\n        clearContextId();\n      },\n      on: {\n        [MOUSE_ENTER]: VISIBLE,\n        [FOCUS]: VISIBLE,\n        [TIME_COMPLETE]: IDLE,\n      },\n    },\n    [DISMISSED]: {\n      leave: () => {\n        // allows us to come on back later w/o entering something else first\n        context.id = null;\n      },\n      on: {\n        [MOUSE_LEAVE]: IDLE,\n        [BLUR]: IDLE,\n      },\n    },\n  },\n};\n\n/*\n * Chart context allows us to persist some data around, in Tooltip all we use\n * is the id of the current tooltip being interacted with.\n */\nlet context: StateContext = { id: null };\nlet state = chart.initial;\n\n////////////////////////////////////////////////////////////////////////////////\n// Subscriptions:\n//\n// We could require apps to render a <TooltipProvider> around the app and use\n// React context to notify Tooltips of changes to our state machine, instead\n// we manage subscriptions ourselves and simplify the Tooltip API.\n//\n// Maybe if default context could take a hook (instead of just a static value)\n// that was rendered at the root for us, that'd be cool! But it doesn't.\nlet subscriptions: Function[] = [];\n\nfunction subscribe(fn: Function) {\n  subscriptions.push(fn);\n  return () => {\n    subscriptions.splice(subscriptions.indexOf(fn), 1);\n  };\n}\n\nfunction notify() {\n  subscriptions.forEach((fn) => fn(state, context));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Timeouts:\n\n// Manages when the user \"rests\" on an element. Keeps the interface from being\n// flashing tooltips all the time as the user moves the mouse around the screen.\nlet restTimeout: number;\n\nfunction startRestTimer() {\n  window.clearTimeout(restTimeout);\n  restTimeout = window.setTimeout(() => transition(REST), MOUSE_REST_TIMEOUT);\n}\n\nfunction clearRestTimer() {\n  window.clearTimeout(restTimeout);\n}\n\n// Manages the delay to hide the tooltip after rest leaves.\nlet leavingVisibleTimer: number;\n\nfunction startLeavingVisibleTimer() {\n  window.clearTimeout(leavingVisibleTimer);\n  leavingVisibleTimer = window.setTimeout(\n    () => transition(TIME_COMPLETE),\n    LEAVE_TIMEOUT\n  );\n}\n\nfunction clearLeavingVisibleTimer() {\n  window.clearTimeout(leavingVisibleTimer);\n}\n\n// allows us to come on back later w/o entering something else first after the\n// user leaves or dismisses\nfunction clearContextId() {\n  context.id = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * useTooltip\n *\n * @param params\n */\nfunction useTooltip<T extends HTMLElement>({\n  id: idProp,\n  onMouseEnter,\n  onMouseMove,\n  onMouseLeave,\n  onFocus,\n  onBlur,\n  onKeyDown,\n  onMouseDown,\n  ref: forwardedRef,\n  DEBUG_STYLE,\n}: {\n  ref?: React.Ref<any>;\n  DEBUG_STYLE?: boolean;\n} & React.HTMLAttributes<T> = {}): [TriggerParams, TooltipParams, boolean] {\n  let id = String(useId(idProp));\n\n  let [isVisible, setIsVisible] = React.useState(\n    DEBUG_STYLE\n      ? true\n      : id === null\n      ? false\n      : context.id === id && state === VISIBLE\n  );\n\n  // hopefully they always pass a ref if they ever pass one\n  let ownRef = React.useRef<HTMLDivElement | null>(null);\n\n  let ref = useForkedRef(forwardedRef as any, ownRef); // TODO: Fix in utils\n  let triggerRect = useRect(ownRef, { observe: isVisible });\n\n  React.useEffect(() => {\n    return subscribe(() => {\n      if (\n        context.id === id &&\n        (state === VISIBLE || state === LEAVING_VISIBLE)\n      ) {\n        setIsVisible(true);\n      } else {\n        setIsVisible(false);\n      }\n    });\n  }, [id]);\n\n  useCheckStyles(\"tooltip\");\n\n  React.useEffect(() => {\n    let ownerDocument = getOwnerDocument(ownRef.current)!;\n    function listener(event: KeyboardEvent) {\n      if (\n        (event.key === \"Escape\" || event.key === \"Esc\") &&\n        state === VISIBLE\n      ) {\n        transition(SELECT_WITH_KEYBOARD);\n      }\n    }\n    ownerDocument.addEventListener(\"keydown\", listener);\n    return () => ownerDocument.removeEventListener(\"keydown\", listener);\n  }, []);\n\n  function handleMouseEnter() {\n    transition(MOUSE_ENTER, { id });\n  }\n\n  function handleMouseMove() {\n    transition(MOUSE_MOVE, { id });\n  }\n\n  function handleFocus() {\n    // @ts-ignore\n    if (window.__REACH_DISABLE_TOOLTIPS) {\n      return;\n    }\n    transition(FOCUS, { id });\n  }\n\n  function handleMouseLeave() {\n    transition(MOUSE_LEAVE);\n  }\n\n  function handleBlur() {\n    // Allow quick click from one tool to another\n    if (context.id !== id) return;\n    transition(BLUR);\n  }\n\n  function handleMouseDown() {\n    // Allow quick click from one tool to another\n    if (context.id !== id) return;\n    transition(MOUSE_DOWN);\n  }\n\n  function handleKeyDown(event: React.KeyboardEvent<T>) {\n    if (event.key === \"Enter\" || event.key === \" \") {\n      transition(SELECT_WITH_KEYBOARD);\n    }\n  }\n\n  let trigger: TriggerParams = {\n    // The element that triggers the tooltip references the tooltip element with\n    // `aria-describedby`.\n    // https://www.w3.org/TR/wai-aria-practices-1.2/#tooltip\n    \"aria-describedby\": isVisible ? makeId(\"tooltip\", id) : undefined,\n    \"data-reach-tooltip-trigger\": \"\",\n    ref,\n    onMouseEnter: wrapEvent(onMouseEnter, handleMouseEnter),\n    onMouseMove: wrapEvent(onMouseMove, handleMouseMove),\n    onFocus: wrapEvent(onFocus, handleFocus),\n    onBlur: wrapEvent(onBlur, handleBlur),\n    onMouseLeave: wrapEvent(onMouseLeave, handleMouseLeave),\n    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),\n    onMouseDown: wrapEvent(onMouseDown, handleMouseDown),\n  };\n\n  let tooltip: TooltipParams = {\n    id,\n    triggerRect,\n    isVisible,\n  };\n\n  return [trigger, tooltip, isVisible];\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Tooltip\n *\n * @see Docs https://reach.tech/tooltip#tooltip\n */\nconst Tooltip = forwardRefWithAs<TooltipProps, \"div\">(function (\n  {\n    children,\n    label,\n    // TODO: Remove `ariaLabel` prop in 1.0 and just use `aria-label`\n    ariaLabel: DEPRECATED_ariaLabel,\n    id,\n    DEBUG_STYLE,\n    ...props\n  },\n  forwardedRef\n) {\n  let child = React.Children.only(children) as any;\n\n  warning(\n    !DEPRECATED_ariaLabel,\n    \"The `ariaLabel prop is deprecated and will be removed from @reach/tooltip in a future version of Reach UI. Please use `aria-label` instead.\"\n  );\n\n  // We need to pass some properties from the child into useTooltip\n  // to make sure users can maintain control over the trigger's ref and events\n  let [trigger, tooltip] = useTooltip({\n    id,\n    onMouseEnter: child.props.onMouseEnter,\n    onMouseMove: child.props.onMouseMove,\n    onMouseLeave: child.props.onMouseLeave,\n    onFocus: child.props.onFocus,\n    onBlur: child.props.onBlur,\n    onKeyDown: child.props.onKeyDown,\n    onMouseDown: child.props.onMouseDown,\n    ref: child.ref,\n    DEBUG_STYLE,\n  });\n  return (\n    <React.Fragment>\n      {React.cloneElement(child, trigger as any)}\n      <TooltipPopup\n        ref={forwardedRef}\n        label={label}\n        aria-label={DEPRECATED_ariaLabel}\n        {...tooltip}\n        {...props}\n      />\n    </React.Fragment>\n  );\n});\n\ntype TooltipProps = {\n  children: React.ReactNode;\n  DEBUG_STYLE?: boolean;\n} & Omit<TooltipContentProps, \"triggerRect\" | \"isVisible\">;\n\nif (__DEV__) {\n  Tooltip.displayName = \"Tooltip\";\n  Tooltip.propTypes = {\n    children: PropTypes.node.isRequired,\n    label: PropTypes.node.isRequired,\n    ariaLabel: PropTypes.string,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * TooltipPopup\n *\n * @see Docs https://reach.tech/tooltip#tooltippopup\n */\nconst TooltipPopup = forwardRefWithAs<TooltipPopupProps, \"div\">(\n  function TooltipPopup(\n    {\n      // could use children but we want to encourage simple strings\n      label,\n      // TODO: Remove `ariaLabel` prop in 1.0 and just use `aria-label`\n      ariaLabel: DEPRECATED_ariaLabel,\n      isVisible,\n      id,\n      ...props\n    },\n    forwardRef\n  ) {\n    return isVisible ? (\n      <Portal>\n        <TooltipContent\n          ref={forwardRef}\n          label={label}\n          aria-label={DEPRECATED_ariaLabel}\n          isVisible={isVisible}\n          {...props}\n          id={makeId(\"tooltip\", String(id))}\n        />\n      </Portal>\n    ) : null;\n  }\n);\n\ntype TooltipPopupProps = {\n  children?: React.ReactNode;\n} & TooltipContentProps;\n\nif (__DEV__) {\n  TooltipPopup.displayName = \"TooltipPopup\";\n  TooltipPopup.propTypes = {\n    label: PropTypes.node.isRequired,\n    ariaLabel: PropTypes.string,\n    position: PropTypes.func,\n  };\n}\n\n/**\n * TooltipContent\n *\n * We need a separate component so that useRect works inside the portal.\n *\n * @see Docs https://reach.tech/tooltip#tooltipcontent\n */\nconst TooltipContent = forwardRefWithAs<TooltipContentProps, \"div\">(\n  function TooltipContent(\n    {\n      // TODO: Remove `ariaLabel` prop in 1.0 and just use `aria-label`\n      ariaLabel,\n      \"aria-label\": realAriaLabel,\n      as: Comp = \"div\",\n      id,\n      isVisible,\n      label,\n      position = positionDefault,\n      style,\n      triggerRect,\n      ...props\n    },\n    forwardedRef\n  ) {\n    // The element that serves as the tooltip container has role tooltip.\n    // https://www.w3.org/TR/wai-aria-practices-1.2/#tooltip\n    // When an app passes an `aria-label`, we actually want to implement\n    // `role=\"tooltip\"` on a visually hidden element inside of the trigger.\n    // In these cases we want the screen reader user to know both the content in\n    // the tooltip, but also the content in the badge. For screen reader users,\n    // the only content announced to them is whatever is in the tooltip.\n    let hasAriaLabel = (realAriaLabel || ariaLabel) != null;\n\n    let ownRef = React.useRef(null);\n    let ref = useForkedRef(forwardedRef, ownRef);\n    let tooltipRect = useRect(ownRef, { observe: isVisible });\n    return (\n      <React.Fragment>\n        <Comp\n          role={hasAriaLabel ? undefined : \"tooltip\"}\n          {...props}\n          ref={ref}\n          data-reach-tooltip=\"\"\n          id={hasAriaLabel ? undefined : id}\n          style={{\n            ...style,\n            ...getStyles(position, triggerRect as PRect, tooltipRect as PRect),\n          }}\n        >\n          {label}\n        </Comp>\n        {hasAriaLabel && (\n          <VisuallyHidden role=\"tooltip\" id={id}>\n            {realAriaLabel || ariaLabel}\n          </VisuallyHidden>\n        )}\n      </React.Fragment>\n    );\n  }\n);\n\ntype TooltipContentProps = {\n  ariaLabel?: string;\n  position?: Position;\n  label: React.ReactNode;\n  isVisible?: boolean;\n  triggerRect: DOMRect | null;\n};\n\nif (__DEV__) {\n  TooltipContent.displayName = \"TooltipContent\";\n  TooltipContent.propTypes = {};\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// feels awkward when it's perfectly aligned w/ the trigger\nconst OFFSET = 8;\n\nfunction getStyles(\n  position: Position,\n  triggerRect: PRect,\n  tooltipRect: PRect\n): React.CSSProperties {\n  let haventMeasuredTooltipYet = !tooltipRect;\n  if (haventMeasuredTooltipYet) {\n    return { visibility: \"hidden\" };\n  }\n  return position(triggerRect, tooltipRect);\n}\n\nlet positionDefault: Position = (triggerRect, tooltipRect) => {\n  let { width: windowWidth, height: windowHeight } = getDocumentDimensions();\n  if (!triggerRect || !tooltipRect) {\n    return {};\n  }\n\n  let collisions = {\n    top: triggerRect.top - tooltipRect.height < 0,\n    right: windowWidth < triggerRect.left + tooltipRect.width,\n    bottom: windowHeight < triggerRect.bottom + tooltipRect.height + OFFSET,\n    left: triggerRect.left - tooltipRect.width < 0,\n  };\n\n  let directionRight = collisions.right && !collisions.left;\n  let directionUp = collisions.bottom && !collisions.top;\n\n  return {\n    left: directionRight\n      ? `${triggerRect.right - tooltipRect.width + window.pageXOffset}px`\n      : `${triggerRect.left + window.pageXOffset}px`,\n    top: directionUp\n      ? `${\n          triggerRect.top - OFFSET - tooltipRect.height + window.pageYOffset\n        }px`\n      : `${\n          triggerRect.top + OFFSET + triggerRect.height + window.pageYOffset\n        }px`,\n  };\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Finds the next state from the current state + action. If the chart doesn't\n * describe that transition, it will throw.\n *\n * It also manages lifecycles of the machine, (enter/leave hooks on the state\n * chart)\n *\n * @param event\n * @param payload\n */\nconst transition: Transition = (event, payload) => {\n  let stateDef = chart.states[state];\n  let nextState = stateDef && stateDef.on && stateDef.on[event];\n\n  // Really useful for debugging\n  // console.log({ event, state, nextState, contextId: context.id });\n  // !nextState && console.log('no transition taken')\n\n  if (!nextState) {\n    return;\n  }\n\n  if (stateDef && stateDef.leave) {\n    stateDef.leave();\n  }\n\n  if (payload) {\n    context = payload;\n  }\n\n  let nextDef = chart.states[nextState];\n  if (nextDef && nextDef.enter) {\n    nextDef.enter();\n  }\n\n  state = nextState;\n  notify();\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// TYPES\n\ninterface TriggerParams {\n  \"aria-describedby\"?: string | undefined;\n  \"data-reach-tooltip-trigger\": string;\n  ref: React.Ref<any>;\n  onMouseEnter: React.ReactEventHandler;\n  onMouseMove: React.ReactEventHandler;\n  onFocus: React.ReactEventHandler;\n  onBlur: React.ReactEventHandler;\n  onMouseLeave: React.ReactEventHandler;\n  onKeyDown: React.ReactEventHandler;\n  onMouseDown: React.ReactEventHandler;\n}\n\ninterface TooltipParams {\n  id: string;\n  triggerRect: DOMRect | null;\n  isVisible: boolean;\n}\n\ntype Transition = (event: MachineEventType, payload?: any) => any;\n\ntype State = \"IDLE\" | \"FOCUSED\" | \"VISIBLE\" | \"LEAVING_VISIBLE\" | \"DISMISSED\";\n\ntype MachineEventType =\n  | \"BLUR\"\n  | \"FOCUS\"\n  | \"GLOBAL_MOUSE_MOVE\"\n  | \"MOUSE_DOWN\"\n  | \"MOUSE_ENTER\"\n  | \"MOUSE_LEAVE\"\n  | \"MOUSE_MOVE\"\n  | \"REST\"\n  | \"SELECT_WITH_KEYBOARD\"\n  | \"TIME_COMPLETE\";\n\ninterface StateChart {\n  initial: State;\n  states: {\n    [key in State]?: {\n      enter?: Function;\n      leave?: Function;\n      on: {\n        [key in MachineEventType]?: State;\n      };\n    };\n  };\n}\n\ntype StateContext = {\n  id?: string | null;\n};\n\ntype Position = (\n  targetRect?: PRect | null,\n  popoverRect?: PRect | null\n) => React.CSSProperties;\n\ntype PRect = Partial<DOMRect> & {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Exports\n\nexport default Tooltip;\nexport type {\n  Position,\n  TooltipContentProps,\n  TooltipParams,\n  TooltipPopupProps,\n  TooltipProps,\n  TriggerParams,\n};\nexport { MOUSE_REST_TIMEOUT, LEAVE_TIMEOUT, Tooltip, TooltipPopup, useTooltip };\n"],"names":["restTimeout","leavingVisibleTimer","chart","initial","states","enter","clearContextId","on","window","clearTimeout","setTimeout","transition","leave","context","id","state","subscriptions","useTooltip","onMouseEnter","onMouseMove","onMouseLeave","onFocus","onBlur","onKeyDown","onMouseDown","forwardedRef","ref","DEBUG_STYLE","String","useId","React","isVisible","setIsVisible","ownRef","useForkedRef","triggerRect","useRect","observe","push","fn","splice","indexOf","useCheckStyles","ownerDocument","getOwnerDocument","current","listener","event","key","addEventListener","removeEventListener","makeId","undefined","wrapEvent","__REACH_DISABLE_TOOLTIPS","Tooltip","forwardRefWithAs","children","label","DEPRECATED_ariaLabel","ariaLabel","props","child","only","tooltip","TooltipPopup","forwardRef","Portal","TooltipContent","realAriaLabel","as","Comp","position","positionDefault","style","hasAriaLabel","tooltipRect","role","getStyles","VisuallyHidden","visibility","getDocumentDimensions","left","width","right","pageXOffset","top","height","bottom","pageYOffset","payload","stateDef","nextState","nextDef","forEach"],"mappings":"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"}